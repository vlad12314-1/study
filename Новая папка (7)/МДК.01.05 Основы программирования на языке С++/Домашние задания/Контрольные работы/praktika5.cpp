/*Часть A: Теоретические вопросы
Разница между std::vector и обычным массивом:

Размер: std::vector — динамический (может расти и сжиматься во время выполнения). Обычный массив (int arr[10]) — статический (его размер фиксирован на этапе компиляции).

Управление памятью: vector сам управляет памятью (выделяет её в куче), при переполнении выделяет новый больший блок и копирует туда элементы. Массив обычно лежит на стеке.

Функциональность: vector предоставляет множество методов (push_back, size(), reserve, итераторы и т.д.). Массив не имеет встроенных методов.

Безопасность: vector при обращении через at() проверяет границы (кидает исключение), в то время как доступ к массиву по индексу за его пределы — неопределенное поведение (UB).

Когда использовать std::string_view, а когда std::string:

std::string_view: Используется, когда нужно только читать строку, не изменяя и не копируя её. Например, при передаче параметров в функцию для анализа (парсинга), когда время жизни строки гарантированно дольше, чем время работы функции. Это дешево (обычно 2 указателя/размера).

std::string: Используется, когда нужно владеть строкой (хранить её, модифицировать, возвращать из функции).

Разница между system_clock и steady_clock:

system_clock: Отображает реальное "настенное" время. Подвержен изменениям (например, синхронизация времени по NTP, перевод часов администратором). Подходит для работы с датами и временем в календаре.

steady_clock: Монотонные часы. Гарантированно идут только вперед и не корректируются. Идеально подходят для измерения интервалов времени (замеров производительности).

Когда лучше использовать исключения (throw), а когда std::optional:

Исключения (throw): Используются для обработки критических, исключительных ситуаций, которые нарушают нормальную работу программы и не должны возникать в корректно работающем коде (например, нехватка памяти, ошибка подключения к базе данных, выход за пределы массива).

std::optional: Используется, когда отсутствие значения — это ожидаемый сценарий работы, а не ошибка. Например, поиск элемента в контейнере ("значение может быть, а может и не быть"), парсинг числа из строки.

Этапы компиляции C++-проекта:

Препроцессирование: Обработка директив #include (вставка содержимого заголовочных файлов), #define (подстановка макросов), #if (условная компиляция). Результат — "чистый" код на C++.

Компиляция: Трансляция C++ кода в ассемблерный код, специфичный для целевой платформы.

Ассемблирование: Трансляция ассемблерного кода в машинный код (объектные файлы .o или .obj). На этом этапе уже есть бинарный код, но адреса функций из других файлов еще не определены.

Линковка (Компоновка): Сборка всех объектных файлов и статических библиотек в один исполняемый файл. На этом этапе компоновщик подставляет реальные адреса функций, разрешая все ссылки.*/
